#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""ord

Output Python's ord() for all the characters within the input string,
with support for different bases, such as hexadecimal, octal, and
binary, as well as the option of including their respective prefixes
(0x, 0o, 0b).

REQUIRES: Python 3.10+

USAGE: `ord "hello there"`

USAGE: `echo hello there | ord`

USAGE: `ord --help`
"""

import sys
from argparse import SUPPRESS, ArgumentParser, Namespace, RawTextHelpFormatter
from typing import Callable

__author__ = "Vincent Lin"

DESCRIPTION = """\
Get the Unicode code point for each character in a string.
"""

parser = ArgumentParser(prog=sys.argv[0],
                        description=DESCRIPTION,
                        formatter_class=RawTextHelpFormatter,
                        add_help=False)

parser.add_argument("--help", action="help", default=SUPPRESS,
                    help="show this message and exit")

parser.add_argument("string", metavar="STRING", nargs="?",
                    help="text string to operate on")
parser.add_argument("-p", "--prefixed", action="store_true",
                    help="keep the radix prefix (0x, 0o, 0b)")
parser.add_argument("-e", "--echo", action="store_true",
                    help="print the original characters alongside")
parser.add_argument("-u", "--uppercase", "--upper", action="store_true",
                    help="use uppercase letters for hexadecimal digits")

bases_group = parser.add_mutually_exclusive_group()

bases_group.add_argument("-x", "-h", "--hexadecimal", "--hex",
                         action="store_true",
                         help="use hexadecimal code points")
bases_group.add_argument("-X", action="store_true",
                         help="equivalent to specifying -x and -u")
bases_group.add_argument("-o", "--octal", "--oct", action="store_true",
                         help="use octal code points")
bases_group.add_argument("-b", "--binary", "--bin", action="store_true",
                         help="use binary code points")

sep_group = parser.add_mutually_exclusive_group()

sep_group.add_argument("-c", "--combined", "--packed", action="store_true",
                       help="pack values instead of delimiting with spaces")
sep_group.add_argument("-1", dest="one_per_line", action="store_true",
                       help="print each entry on its own line")


def escaped(ch: str) -> str:
    r"""
    Return a string representation that can be safely printed without
    messing up formatting.

    NOTE: It is expected that len(escaped(ch)) will be no more than 2,
    with such characters including the escape sequences common in TEXT
    files such as \n and \t.  Attempting to feed binary data into this
    program may result in this function returning longer strings like
    \x00, etc. which may compromise the spacing in the final output.
    """
    return repr(ch).strip("'\"")


def print_one_per_line(string: str, echo: bool,
                       char_formatter: Callable[[str], str]
                       ) -> None:
    """Handle the case where each result goes on a separate line."""
    if echo:
        def format_line(ch: str, /) -> str:
            # Width: accommodate (text) escape sequences e.g. \n, \t
            return f"{escaped(ch).rjust(2)} {char_formatter(ch)}"
    else:
        format_line = char_formatter
    lines = "\n".join(format_line(ch) for ch in string)
    print(lines)


def get_char_formatting(namespace: Namespace
                        ) -> tuple[Callable[[str], str], str, int]:
    """
    Parse the options to construct a function that will take a character
    and format it with the appropriate code point value as well as
    prefix and spacing.  Also return this prefix and fill width.

    Returns:
        tuple[Callable[[str], str], str, int]: A 3-tuple containing the
        char formatter function, the radix prefix, and fill width.
    """
    prefixed: bool = namespace.prefixed
    uppercase: bool = namespace.uppercase or namespace.X
    combined: bool = namespace.combined

    match namespace:
        # TODO: The fill widths below only work assuming all input
        # characters are ASCII.  Unicode characters whose code points
        # are represented beyond width digits will mess up the spacing
        # when echoing them with the ord() values.
        case Namespace(hexadecimal=True) | Namespace(X=True):
            caster = hex
            prefix = "0x"
            width = 2
        case Namespace(octal=True):
            caster = oct
            prefix = "0o"
            width = 3
        case Namespace(binary=True):
            caster = bin
            prefix = "0b"
            width = 8
        case _:
            caster = str
            prefix = ""
            width = 3

    def char_formatter(ch: str, /) -> str:
        code = ord(ch)
        casted = caster(code).removeprefix(prefix).zfill(width)
        if uppercase:
            casted = casted.upper()
        # Caller's responsibility to tack a single prefix onto the
        # combined string.
        if combined:
            return casted
        return (prefix if prefixed else "") + casted

    return char_formatter, prefix, width


def main() -> None:
    """Main driver function."""
    namespace = parser.parse_args()

    string: str | None = namespace.string
    if string is None:
        string = sys.stdin.read()

    prefixed: bool = namespace.prefixed
    echo: bool = namespace.echo
    combined: bool = namespace.combined
    one_per_line: bool = namespace.one_per_line

    char_formatter, prefix, width = get_char_formatting(namespace)

    if one_per_line:
        print_one_per_line(string, echo, char_formatter)
        return

    delimiter = "" if combined else " "
    output = delimiter.join(char_formatter(ch) for ch in string)
    if combined and prefixed:
        output = prefix + output

    if echo:
        echoed = delimiter.join(escaped(ch).ljust(width) for ch in string)
        print(echoed)
    print(output)


if __name__ == "__main__":
    main()

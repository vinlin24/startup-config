#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""ord

Output Python's ord() for all the characters within the input string,
with support for different bases, such as hexadecimal, octal, and
binary, as well as the option of including their respective prefixes
(0x, 0o, 0b).

REQUIRES: Python 3.10+

USAGE: `ord "hello there"`

USAGE: `echo hello there | ord`

USAGE: `ord --help`
"""

import math
import sys
from argparse import SUPPRESS, ArgumentParser, Namespace, RawTextHelpFormatter
from pathlib import Path

__author__ = "Vincent Lin"

DESCRIPTION = """\
Get the Unicode code point for each character in a string.
"""

parser = ArgumentParser(prog=Path(sys.argv[0]).name,
                        description=DESCRIPTION,
                        formatter_class=RawTextHelpFormatter,
                        add_help=False)

parser.add_argument("--help", action="help", default=SUPPRESS,
                    help="show this message and exit")

parser.add_argument("string", metavar="STRING", nargs="?",
                    help="text string to operate on")
parser.add_argument("-p", "--prefixed", action="store_true",
                    help="keep the radix prefix (0x, 0o, 0b)")
parser.add_argument("-e", "--echo", action="store_true",
                    help="print the original characters alongside")
parser.add_argument("-u", "--uppercase", "--upper", action="store_true",
                    help="use uppercase letters for hexadecimal digits")

bases_group = parser.add_mutually_exclusive_group()

bases_group.add_argument("-x", "-h", "--hexadecimal", "--hex",
                         action="store_true",
                         help="use hexadecimal code points")
bases_group.add_argument("-X", action="store_true",
                         help="equivalent to specifying -x and -u")
bases_group.add_argument("-o", "--octal", "--oct", action="store_true",
                         help="use octal code points")
bases_group.add_argument("-b", "--binary", "--bin", action="store_true",
                         help="use binary code points")

parser.add_argument("-1", dest="one_per_line", action="store_true",
                    help="print each entry on its own line")


# pylint: disable=too-few-public-methods
class CharFormatter:
    """Configurable code point formatter to use on each character.

    USAGE::

        namespace = parser.parse_args()
        char_formatter = CharFormatter(namespace)
        formatted = char_formatter("A")  # __call__
    """

    def __init__(self, options: Namespace) -> None:
        self.prefixed: bool = options.prefixed
        self.uppercase: bool = options.uppercase or options.X

        # Compute upfront how much fill width we'll need.
        self.string: str = options.string
        self._max_codepoint = max(ord(ch) for ch in self.string)

        match options:
            # TODO: The fill widths below only work assuming all input
            # characters are ASCII.  Unicode characters whose code points
            # are represented beyond width digits will mess up the
            # spacing when echoing them with the ord() values.
            case Namespace(hexadecimal=True) | Namespace(X=True):
                self.caster = hex
                self.prefix = "0x"
                self.width = self._digits_needed(digits_per_bit=4)
            case Namespace(octal=True):
                self.caster = oct
                self.prefix = "0o"
                self.width = self._digits_needed(digits_per_bit=3)
            case Namespace(binary=True):
                self.caster = bin
                self.prefix = "0b"
                self.width = self._digits_needed(digits_per_bit=1)
            case _:
                self.caster = str
                self.prefix = ""
                self.width = len(str(self._max_codepoint))

        # The maximum width needed for a char in the original string.
        self.original_max_width = max(len(escaped(ch)) for ch in self.string)

    def __call__(self, ch: str, echoing: bool) -> str:
        code = ord(ch)

        if echoing:
            width = max(self.width, self.original_max_width)
        else:
            width = self.width

        casted = self.caster(code).removeprefix(self.prefix).zfill(width)
        if self.uppercase:
            casted = casted.upper()
        return (self.prefix if self.prefixed else "") + casted

    def _digits_needed(self, digits_per_bit: int) -> int:
        if self._max_codepoint == 0:
            next_power_of_2 = 1
        else:
            next_power_of_2 = (2**(self._max_codepoint - 1)).bit_length()
        bits_needed = next_power_of_2.bit_length()
        return math.ceil(bits_needed / digits_per_bit)


def escaped(ch: str) -> str:
    r"""
    Return a string representation that can be safely printed without
    messing up formatting.

    NOTE: It is expected that len(escaped(ch)) will be no more than 2,
    with such characters including the escape sequences common in TEXT
    files such as \n and \t.  Attempting to feed binary data into this
    program may result in this function returning longer strings like
    \x00, etc. which may compromise the spacing in the final output.
    """
    safe = repr(ch).strip("'\"")
    if safe == " ":
        return "SPC"  # So it doesn't break external parsers, prolly.
    return repr(ch).strip("'\"")


def print_one_per_line(string: str, echo: bool,
                       formatter: CharFormatter,
                       ) -> None:
    """Handle the case where each result goes on a separate line."""
    if echo:
        width = formatter.original_max_width

        def format_line(ch: str, echo: bool, /) -> str:
            return f"{escaped(ch).rjust(width)} {formatter(ch, echo)}"
    else:
        format_line = formatter

    lines = "\n".join(format_line(ch, echo) for ch in string)
    print(lines)


def main() -> None:
    """Main driver function."""
    namespace = parser.parse_args()

    if namespace.string is None:
        namespace.string = sys.stdin.read()
    string: str = namespace.string

    echo: bool = namespace.echo
    one_per_line: bool = namespace.one_per_line

    char_formatter = CharFormatter(namespace)

    if one_per_line:
        print_one_per_line(string, echo, char_formatter)
        return

    output = " ".join(char_formatter(ch, echo) for ch in string)

    if echo:
        width = max(char_formatter.width, char_formatter.original_max_width)
        echoed = " ".join(escaped(ch).ljust(width) for ch in string)
        print(echoed)
    print(output)


if __name__ == "__main__":
    main()

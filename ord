#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""ord

Output Python's ord() for all the characters within the input string,
with support for different bases, such as hexadecimal, octal, and
binary, as well as the option of including their respective prefixes
(0x, 0o, 0b).

REQUIRES: Python 3.10+

USAGE: `ord "hello there"`

USAGE: `echo hello there | ord`

USAGE: `ord --help`
"""

import sys
from argparse import SUPPRESS, ArgumentParser, Namespace, RawTextHelpFormatter

__author__ = "Vincent Lin"

DESCRIPTION = """\
Get the Unicode code point for each character in a string.
"""

parser = ArgumentParser(prog=sys.argv[0],
                        description=DESCRIPTION,
                        formatter_class=RawTextHelpFormatter,
                        add_help=False)

parser.add_argument("--help", action="help", default=SUPPRESS,
                    help="show this message and exit")

parser.add_argument("string", metavar="STRING", nargs="?",
                    help="text string to operate on")
parser.add_argument("-p", "--prefixed", action="store_true",
                    help="keep the radix prefix (0x, 0o, 0b)")
parser.add_argument("-e", "--echo", action="store_true",
                    help="print the original characters alongside")
parser.add_argument("-u", "--uppercase", "--upper", action="store_true",
                    help="use uppercase letters for hexadecimal digits")

bases_group = parser.add_mutually_exclusive_group()

bases_group.add_argument("-x", "-h", "--hexadecimal", "--hex",
                         action="store_true",
                         help="use hexadecimal code points")
bases_group.add_argument("-X", action="store_true",
                         help="equivalent to specifying -x and -u")
bases_group.add_argument("-o", "--octal", "--oct", action="store_true",
                         help="use octal code points")
bases_group.add_argument("-b", "--binary", "--bin", action="store_true",
                         help="use binary code points")

sep_group = parser.add_mutually_exclusive_group()

sep_group.add_argument("-c", "--combined", "--packed", action="store_true",
                       help="pack values instead of delimiting with spaces")
sep_group.add_argument("-1", dest="one_per_line", action="store_true",
                       help="print each entry on its own line")


# pylint: disable=too-few-public-methods
class CharFormatter:
    """Configurable code point formatter to use on each character.

    USAGE::

        namespace = parser.parse_args()
        char_formatter = CharFormatter(namespace)
        formatted = char_formatter("A")  # __call__
    """

    def __init__(self, options: Namespace) -> None:
        self.prefixed: bool = options.prefixed
        self.uppercase: bool = options.uppercase or options.X
        self.combined: bool = options.combined

        match options:
            # TODO: The fill widths below only work assuming all input
            # characters are ASCII.  Unicode characters whose code points
            # are represented beyond width digits will mess up the
            # spacing when echoing them with the ord() values.
            case Namespace(hexadecimal=True) | Namespace(X=True):
                self.caster = hex
                self.prefix = "0x"
                self.width = 2
            case Namespace(octal=True):
                self.caster = oct
                self.prefix = "0o"
                self.width = 3
            case Namespace(binary=True):
                self.caster = bin
                self.prefix = "0b"
                self.width = 8
            case _:
                self.caster = str
                self.prefix = ""
                self.width = 3

    def __call__(self, ch: str) -> str:
        code = ord(ch)
        casted = self.caster(code).removeprefix(self.prefix).zfill(self.width)
        if self.uppercase:
            casted = casted.upper()
        # Caller's responsibility to tack a single prefix onto the
        # combined string.
        if self.combined:
            return casted
        return (self.prefix if self.prefixed else "") + casted


def escaped(ch: str) -> str:
    r"""
    Return a string representation that can be safely printed without
    messing up formatting.

    NOTE: It is expected that len(escaped(ch)) will be no more than 2,
    with such characters including the escape sequences common in TEXT
    files such as \n and \t.  Attempting to feed binary data into this
    program may result in this function returning longer strings like
    \x00, etc. which may compromise the spacing in the final output.
    """
    return repr(ch).strip("'\"")


def print_one_per_line(string: str, echo: bool,
                       formatter: CharFormatter
                       ) -> None:
    """Handle the case where each result goes on a separate line."""
    if echo:
        def format_line(ch: str, /) -> str:
            # Width: accommodate (text) escape sequences e.g. \n, \t
            return f"{escaped(ch).rjust(2)} {formatter(ch)}"
    else:
        format_line = formatter
    lines = "\n".join(format_line(ch) for ch in string)
    print(lines)


def main() -> None:
    """Main driver function."""
    namespace = parser.parse_args()

    string: str | None = namespace.string
    if string is None:
        string = sys.stdin.read()

    prefixed: bool = namespace.prefixed
    echo: bool = namespace.echo
    combined: bool = namespace.combined
    one_per_line: bool = namespace.one_per_line

    char_formatter = CharFormatter(namespace)
    prefix = char_formatter.prefix
    width = char_formatter.width

    if one_per_line:
        print_one_per_line(string, echo, char_formatter)
        return

    delimiter = "" if combined else " "
    output = delimiter.join(char_formatter(ch) for ch in string)
    if combined and prefixed:
        output = prefix + output

    if echo:
        echoed = delimiter.join(escaped(ch).ljust(width) for ch in string)
        print(echoed)
    print(output)


if __name__ == "__main__":
    main()
